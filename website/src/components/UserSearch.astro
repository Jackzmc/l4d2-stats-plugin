---
import Field from './bulma/Field.astro'
interface Prop {
    size?: string
}
const { size = "" } = Astro.props 
---
<form autocomplete="off" method="get" action="/users">
    <div class="search-autocomplete">
        <Field iconLeft="iconoir:search" iconLeftProps={{class: "has-text-black"}}>
            <input required minlength={3} name="q" class:list={["input","search",size]} type="text" placeholder="Search users" />
        </Field>
        <div class="search-items"></div>
    </div>
</form>

<style is:global>
.search-autocomplete {
    position: relative;
    display: inline-block;
}
.search-items div {
    border: 1px solid black;

}
.search-items {
    position: absolute;
    z-index: 99;
    top: 100%;
    left: 0;
    right: 0;
    background-color: white;
}
.search-items div a:hover {
    background-color: gray;
    color: white;
}
.search-items div a.box {
    border-radius: 0;
}
</style>

<script>
import type { PlayerSearchResult } from "@/models/User.ts";

const DEBOUNCE_TIME = 300

// https://stackoverflow.com/a/75988895 Modified with TS types
const debounce = (callback: (...args: any[]) => void, wait: number) => {
  let timeoutId: number|undefined;
  return (...args: any[]) => {
    clearTimeout(timeoutId);
    timeoutId = window.setTimeout(() => {
      callback(...args);
    }, wait);
  };
}

async function search(query: string, cb: (users: PlayerSearchResult[]) => void) {
    const response = await fetch(`/api/search?q=${query}`)
    if(response.ok) {
        const users: PlayerSearchResult[] = await response.json()
        cb(users)
    } else {
        throw new Error(`${response.status} ${response.statusText}`)
    }
}
function updateAutocomplete(list: HTMLInputElement, items: PlayerSearchResult[]) {
    // Remove old children
    clearLists()

    for(const item of items) {
        const div = document.createElement("div")
        const a = document.createElement("a")
        a.classList = "box"
        a.href = `/users/${item.steamid}/overview`

        const p = document.createElement("p")
        const name = document.createElement("strong")
        name.textContent = item.name
        p.append(name)
        a.append(p)

        const steamid = document.createElement("span")
        steamid.classList = "is-inline has-text-right"
        steamid.textContent = item.steamid
        a.append(steamid)
        div.append(a)

        list.append(div)
    }
}
const searchDebounced = debounce(search, DEBOUNCE_TIME)


const searchInputs = document.querySelectorAll<HTMLInputElement>("input[name=q]")
for(const input of searchInputs) {
    input.addEventListener("input", onSearchInput)
}
document.addEventListener("click", (ev) => {
    clearLists()
})

let ignore = false

function clearLists() {
    const lists = document.querySelectorAll(".search-autocomplete .search-items")
    for(const list of lists) {
        for(const child of list.childNodes)
            list.removeChild(child)
    }
}

async function onSearchInput(ev: Event) {
    if(ignore) return

    const input = ev.target as HTMLInputElement
    const value = input.value
    // Ignore too short queries
    if(value.length < 3) return

    // Update all other search inputs with same value
    ignore = true
    for(const input of searchInputs) {
        input.value = value
    }
    ignore = false

    searchDebounced(value, (users: PlayerSearchResult[]) => {
        const list = input.parentElement!.parentElement!.parentElement!.querySelector(".search-items") as HTMLInputElement
        updateAutocomplete(list, users)
    })
}
</script>